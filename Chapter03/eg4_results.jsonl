{"label": "good_prompt", "prompt": "Analyze the security vulnerabilities in this code snippet.\nFocus on SQL injection and authentication bypass.\nCode:\nfrom flask import Flask, request, session\nimport sqlite3, hashlib\n\napp = Flask(__name__)\napp.secret_key = \"dev\"\n\ndef get_db():\n    return sqlite3.connect(\"app.db\")\n\n@app.route(\"/login\", methods=[\"POST\"])\ndef login():\n    username = request.form.get(\"username\", \"\")\n    password = request.form.get(\"password\", \"\")\n    remember = request.form.get(\"remember\", \"0\")\n\n    # SQL injection risk: direct string interpolation of user input\n    conn = get_db()\n    cur = conn.cursor()\n    query = f\"SELECT id, password_hash FROM users WHERE username = '{username}'\"\n    cur.execute(query)\n    row = cur.fetchone()\n\n    if row:\n        # Weak check: truncated hash comparison can be abused\n        hashed = hashlib.sha256(password.encode()).hexdigest()\n        if hashed[:10] == row[1][:10]:\n            session[\"user_id\"] = row[0]\n            # Auth bypass risk: 'remember' flag grants admin privileges\n            if remember == \"1\":\n                session[\"is_admin\"] = True\n            return \"OK\"\n    return \"Unauthorized\", 401", "result": {"text": "### Security Vulnerabilities Analysis\n\n#### 1. **SQL Injection**\n- **Vulnerability**: The code uses direct string interpolation for SQL queries:\n  ```python\n  query = f\"SELECT id, password_hash FROM users WHERE username = '{username}'\"\n  ```\n- **Risk**: Attackers can inject malicious SQL by manipulating the `username` input. For example:\n  - `' OR 1=1 --` would return the first user in the database, bypassing authentication.\n  - `'; DROP TABLE users; --` could delete tables.\n- **Why It's Critical**: Direct string interpolation allows arbitrary SQL execution, compromising data confidentiality, integrity, and availability.\n\n#### 2. **Authentication Bypass via Weak Hash Comparison**\n- **Vulnerability**: Only the first 10 characters of the SHA-256 hash are compared:\n  ```python\n  if hashed[:10] == row[1][:10]:\n  ```\n- **Risk**:\n  - **Brute-Force Feasibility**: 10 hex characters = 40 bits of security. Attackers can brute-force collisions (≈1 trillion possibilities) quickly.\n  - **Collision Attacks**: Different passwords with matching truncated hashes can authenticate as the user.\n- **Impact**: Weak comparison undermines the entire authentication mechanism.\n\n#### 3. **Admin Privilege Escalation**\n- **Vulnerability**: The `remember` flag directly grants admin privileges:\n  ```python\n  if remember == \"1\":\n      session[\"is_admin\"] = True\n  ```\n- **Risk**: Any user can gain admin rights by setting `remember=1` in the request, regardless of their actual role.\n- **Why It's Critical**: Privilege escalation occurs without backend validation, violating the principle of least privilege.\n\n#### 4. **Insecure Password Hashing**\n- **Vulnerability**: \n  - Uses unsalted SHA-256 (cryptographically insecure for passwords).\n  - No key derivation function (e.g., PBKDF2, bcrypt).\n- **Risk**: \n  - **Rainbow Table Attacks**: Unsalted hashes allow precomputed attacks.\n  - **GPU Bruteforcing**: SHA-256 is fast, enabling efficient password cracking.\n\n#### 5. **Missing Input Sanitization**\n- **Vulnerability**: No validation/sanitization of `username` or `password`.\n- **Risk**: Facilitates SQL injection (as above) and other injection attacks.\n\n#### 6. **Hardcoded Secret Key**\n- **Vulnerability**: `app.secret_key = \"dev\"`.\n- **Risk**: Predictable keys allow attackers to forge session cookies and impersonate users.\n\n#### 7. **Database Connection Management**\n- **Vulnerability**: Connections aren’t closed after use.\n- **Risk**: Resource exhaustion, leading to denial-of-service (DoS).\n\n---\n\n### Exploit Scenarios\n1. **SQL Injection + Auth Bypass**:\n   - Send `username=' OR 1=1 --` and any `password` to log in as the first user.\n2. **Admin Escalation**:\n   - Set `remember=1` to become admin after any successful login.\n3. **Brute-Force Password**:\n   - Crack truncated hashes offline (40 bits) to compromise accounts.\n\n---\n\n### Fix Recommendations\n1. **Prevent SQL Injection**:\n   ```python\n   query = \"SELECT id, password_hash FROM users WHERE username = ?\"\n   cur.execute(query, (username,))\n   ```\n\n2. **Use Full-Length Hash Comparisons**:\n   ```python\n   if hashed == row[1]:  # Compare entire hashes\n   ```\n\n3. **Secure Password Hashing**:\n   ```python\n   # Use a dedicated library (e.g., bcrypt)\n   import bcrypt\n   if bcrypt.checkpw(password.encode(), row[1].encode()):\n   ```\n\n4. **Validate Admin Privileges**:\n   - Store `is_admin` in the database and fetch it during login:\n   ```python\n   session[\"is_admin\"] = (row[2] == 1)  # row[2] = is_admin from DB\n   ```\n\n5. **Sanitize Inputs**:\n   - Validate `username`/`password` format (e.g., length, character set).\n\n6. **Use Strong Secret Key**:\n   - Generate a random key: `app.secret_key = os.urandom(32)`.\n\n7. **Close Database Connections**:\n   ```python\n   try:\n       # ... execute query ...\n   finally:\n       conn.close()\n   ```\n\n---\n\n### Fixed Code Snippet\n```python\nfrom flask import Flask, request, session\nimport sqlite3, bcrypt, os\n\napp = Flask(__name__)\napp.secret_key = os.urandom(32)  # Strong random key\n\ndef get_db():\n    return sqlite3.connect(\"app.db\")\n\n@app.route(\"/login\", methods=[\"POST\"])\ndef login():\n    username = request.form.get(\"username\", \"\")\n    password = request.form.get(\"password\", \"\")\n\n    conn = get_db()\n    try:\n        cur = conn.cursor()\n        # Parameterized query to prevent SQLi\n        cur.execute(\"SELECT id, password_hash, is_admin FROM users WHERE username = ?\", (username,))\n        row = cur.fetchone()\n    finally:\n        conn.close()  # Always close connection\n\n    if row:\n        # Verify full hash using bcrypt\n        if bcrypt.checkpw(password.encode(), row[1].encode()):\n            session[\"user_id\"] = row[0]\n            # Set admin flag from database, NOT user input\n            session[\"is_admin\"] = bool(row[2])\n            return \"OK\"\n    return \"Unauthorized\", 401\n```\n\n**Key Improvements**:\n- SQL injection eliminated via parameterized queries.\n- Password security strengthened with `bcrypt`.\n- Admin privileges tied to database values.\n- Secure secret key and resource management.", "latency_seconds": 46.34, "usage": {"prompt_tokens": 276, "completion_tokens": 2336, "total_tokens": 2612}}, "metrics": {"mentions_sql": true, "mentions_auth_bypass": true, "target_hits": 25, "offtopic_hits": 5, "focus_score": 20, "snr": 0.229, "length_words": 607, "sentences": 48}}
{"label": "bad_prompt", "prompt": "You are an expert security researcher with 20 years of experience. I want you to carefully examine the following code, thinking about all possible security issues. Consider things like SQL injection, XSS, CSRF, SSRF, RCE, XXE, authentication problems, cryptographic mistakes, logging leaks, supply-chain risks, misconfigurations, container isolation, and any other vulnerabilities. Provide detailed step-by-step reasoning, multiple attack scenarios, extensive mitigation guidance, references to standards, and discuss broader architectural concerns. Include lists and severity scoring. Here is the code:\nfrom flask import Flask, request, session\nimport sqlite3, hashlib\n\napp = Flask(__name__)\napp.secret_key = \"dev\"\n\ndef get_db():\n    return sqlite3.connect(\"app.db\")\n\n@app.route(\"/login\", methods=[\"POST\"])\ndef login():\n    username = request.form.get(\"username\", \"\")\n    password = request.form.get(\"password\", \"\")\n    remember = request.form.get(\"remember\", \"0\")\n\n    # SQL injection risk: direct string interpolation of user input\n    conn = get_db()\n    cur = conn.cursor()\n    query = f\"SELECT id, password_hash FROM users WHERE username = '{username}'\"\n    cur.execute(query)\n    row = cur.fetchone()\n\n    if row:\n        # Weak check: truncated hash comparison can be abused\n        hashed = hashlib.sha256(password.encode()).hexdigest()\n        if hashed[:10] == row[1][:10]:\n            session[\"user_id\"] = row[0]\n            # Auth bypass risk: 'remember' flag grants admin privileges\n            if remember == \"1\":\n                session[\"is_admin\"] = True\n            return \"OK\"\n    return \"Unauthorized\", 401", "result": {"text": "### Security Analysis of the Provided Flask Login Code\n\n#### **1. SQL Injection (Critical - CVSS 9.8)**\n**Issue**:  \n```python\nquery = f\"SELECT id, password_hash FROM users WHERE username = '{username}'\"\n```\n- **Risk**: Direct string interpolation of `username` allows attackers to inject arbitrary SQL.  \n- **Attack Scenarios**:  \n  - **Bypass Authentication**: `username = ' OR 1=1--` makes the query:  \n    ```sql\n    SELECT id, password_hash FROM users WHERE username = '' OR 1=1--'\n    ```\n    This returns the first user in the database, granting unauthorized access.  \n  - **Data Exfiltration**: `username = ' UNION SELECT 1, sqlite_version()--` leaks DB metadata.  \n  - **Data Deletion**: `username = '; DROP TABLE users;--` deletes the table.  \n\n**Mitigation**:  \n- **Parameterized Queries**:  \n  ```python\n  query = \"SELECT id, password_hash, is_admin FROM users WHERE username = ?\"\n  cur.execute(query, (username,))\n  ```\n- **Standards**: OWASP SQL Injection Prevention [Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html).\n\n---\n\n#### **2. Weak Password Hashing (Critical - CVSS 9.8)**\n**Issues**:  \n```python\nhashed = hashlib.sha256(password.encode()).hexdigest()\nif hashed[:10] == row[1][:10]:\n```\n- **Truncated Hash (40 bits)**: Brute-forced in seconds (10 hex chars = 40 bits).  \n- **No Salt**: Enables rainbow table attacks.  \n- **Fast Algorithm**: SHA-256 is designed for speed, not password storage.  \n\n**Attack Scenario**:  \n- Attacker steals `password_hash` from DB. A GPU cracks a 40-bit hash in <1 second.  \n\n**Mitigation**:  \n- Use **bcrypt**, **scrypt**, or **Argon2** with a cost factor:  \n  ```python\n  import bcrypt\n  # Storing: bcrypt.hashpw(password.encode(), bcrypt.gensalt(rounds=12))\n  # Verifying: bcrypt.checkpw(password.encode(), stored_hash)\n  ```\n- **Standards**: NIST SP 800-63B §5.1.1.2 (Use approved password hashing).\n\n---\n\n#### **3. Broken Authentication Logic (Critical - CVSS 9.1)**\n**Issue**:  \n```python\nif remember == \"1\":\n    session[\"is_admin\"] = True\n```\n- **Admin by Checkbox**: Any user can become admin by setting `remember=1`.  \n- **No Validation**: No check if the user is *actually* an admin in the database.  \n\n**Mitigation**:  \n- Store `is_admin` in the database and fetch it during login:  \n  ```python\n  # In SQL: SELECT ..., is_admin FROM users ...\n  session[\"is_admin\"] = bool(row[2])  # is_admin from DB\n  ```\n\n---\n\n#### **4. Hardcoded Secrets (High - CVSS 8.1)**\n**Issue**:  \n```python\napp.secret_key = \"dev\"\n```\n- **Predictable Key**: Allows session cookie forgery.  \n- **No Key Rotation**: Static keys compromise all sessions if leaked.  \n\n**Mitigation**:  \n- Generate a random secret at runtime via environment variables:  \n  ```python\n  import os\n  app.secret_key = os.environ.get(\"SECRET_KEY\", os.urandom(32))\n  ```\n- **Standards**: Use 32+ bytes of randomness (NIST SP 800-131A).\n\n---\n\n#### **5. Insecure Session Configuration (High - CVSS 7.6)**\n**Missing Protections**:  \n- No `HttpOnly` or `Secure` flags on session cookies.  \n- No SameSite attribute.  \n\n**Risks**:  \n- **XSS Exploits**: Steal session cookies via JavaScript.  \n- **Man-in-the-Middle**: Session hijacking over HTTP.  \n\n**Mitigation**:  \n```python\napp.config.update(\n    SESSION_COOKIE_HTTPONLY=True,\n    SESSION_COOKIE_SECURE=True,  # Enable in production\n    SESSION_COOKIE_SAMESITE='Lax'\n)\n```\n\n---\n\n#### **6. Lack of Input Validation (Medium - CVSS 6.5)**\n**Issue**:  \n```python\nusername = request.form.get(\"username\", \"\")\npassword = request.form.get(\"password\", \"\")\n```\n- **No Sanitization**: Allows unexpected characters (e.g., SQL, XSS payloads).  \n\n**Mitigation**:  \n- Validate inputs (e.g., regex for alphanumeric usernames).  \n- Use libraries like `WTForms` for structured validation.  \n\n---\n\n#### **7. Missing CSRF Protection (High - CVSS 8.8)**\n**Risk**:  \n- Attackers can trick logged-in users into submitting malicious login forms, changing their session state.  \n\n**Mitigation**:  \n- Enable Flask-WTF CSRF protection:  \n  ```python\n  from flask_wtf.csrf import CSRFProtect\n  csrf = CSRFProtect(app)\n  ```\n\n---\n\n#### **8. Database Connection Management (Low - CVSS 3.7)**\n**Issue**:  \n```python\ndef get_db():\n    return sqlite3.connect(\"app.db\")\n```\n- **No Connection Pooling**: Risk of resource exhaustion.  \n- **No Error Handling**: Connections may leak during exceptions.  \n\n**Mitigation**:  \n- Use context managers:  \n  ```python\n  with sqlite3.connect(\"app.db\") as conn:\n      # ...\n  ```\n- Add retry logic for concurrent access.\n\n---\n\n### **Broader Architectural Concerns**\n1. **No Rate Limiting**:  \n   - Brute-force attacks on `/login` are unmitigated.  \n   - **Fix**: Use `flask-limiter` to block excessive attempts.  \n\n2. **Logging & Monitoring**:  \n   - Missing audit logs for login attempts (success/failure).  \n   - **Fix**: Log `username`, IP, timestamp, and outcome (obfuscate sensitive data).  \n\n3. **Credential Storage**:  \n   - Passwords stored with weak hashes (truncated SHA-256).  \n   - **Fix**: Use dedicated password managers (e.g., Vault) or strong hashing.  \n\n4. **Container Isolation**:  \n   - SQLite DB stored in the app directory. If containerized, ensure DB volume is secured.  \n\n5. **Supply-Chain Risks**:  \n   - Dependencies (`flask`, `sqlite3`) not pinned. Could include vulnerable versions.  \n   - **Fix**: Use `requirements.txt` with exact versions and SCA tools (e.g., Dependabot).  \n\n---\n\n### **Severity Summary**\n| Vulnerability               | CVSS | Severity |\n|-----------------------------|------|----------|\n| SQL Injection               | 9.8  | Critical |\n| Weak Password Hashing       | 9.8  | Critical |\n| Broken Authentication Logic | 9.1  | Critical |\n| Hardcoded Secrets           | 8.1  | High     |\n| Missing CSRF Protection     | 8.8  | High     |\n| Insecure Session Config     | 7.6  | High     |\n| No Input Validation         | 6.5  | Medium   |\n| DB Connection Management    | 3.7  | Low      |\n\n---\n\n### **Corrected Code**\n```python\nimport os\nimport bcrypt\nfrom flask import Flask, request, session\nfrom flask_wtf.csrf import CSRFProtect\nimport sqlite3\n\napp = Flask(__name__)\napp.secret_key = os.environ.get(\"SECRET_KEY\", os.urandom(32))\napp.config.update(\n    SESSION_COOKIE_HTTPONLY=True,\n    SESSION_COOKIE_SECURE=True,  # Disable in dev if using HTTP\n    SESSION_COOKIE_SAMESITE='Lax'\n)\ncsrf = CSRFProtect(app)  # CSRF protection\n\ndef get_db():\n    return sqlite3.connect(\"app.db\")\n\n@app.route(\"/login\", methods=[\"POST\"])\ndef login():\n    username = request.form.get(\"username\", \"\")\n    password = request.form.get(\"password\", \"\")\n    remember = request.form.get(\"remember\", \"0\")\n\n    # Input validation (example: alphanumeric username)\n    if not username.isalnum():\n        return \"Invalid username\", 400\n\n    try:\n        with get_db() as conn:\n            cur = conn.cursor()\n            # Parameterized query\n            cur.execute(\n                \"SELECT id, password_hash, is_admin FROM users WHERE username = ?\",\n                (username,)\n            )\n            row = cur.fetchone()\n\n        if row:\n            user_id, password_hash, is_admin = row\n            # Verify password with bcrypt\n            if bcrypt.checkpw(password.encode(), password_hash.encode()):\n                session[\"user_id\"] = user_id\n                session[\"is_admin\"] = bool(is_admin)  # From DB, NOT user input\n                return \"OK\"\n        return \"Unauthorized\", 401\n    except sqlite3.Error as e:\n        app.logger.error(f\"Database error: {e}\")\n        return \"Internal Server Error\", 500\n```\n\n### **Additional Recommendations**\n- **Password Policies**: Enforce minimum length (12+ chars), complexity, and breach checks.  \n- **Multi-Factor Authentication (MFA)**: Critical for admin accounts.  \n- **Security Headers**: Add `Content-Security-Policy`, `X-Content-Type-Options`.  \n- **Error Handling**: Avoid leaking stack traces (disable `debug=True` in production).  \n- **Penetration Testing**: Use tools like OWASP ZAP or Burp Suite.  \n\n### **References**\n- OWASP Top 10 (2021): [A03:2021-Injection](https://owasp.org/Top10/A03_2021-Injection/)\n- NIST Password Guidelines: [SP 800-63B](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-63b.pdf)\n- Flask Security: [Official Documentation](https://flask.palletsprojects.com/en/2.1.x/security/)", "latency_seconds": 182.91, "usage": {"prompt_tokens": 368, "completion_tokens": 4733, "total_tokens": 5101}}, "metrics": {"mentions_sql": true, "mentions_auth_bypass": true, "target_hits": 28, "offtopic_hits": 18, "focus_score": 10, "snr": 0.203, "length_words": 972, "sentences": 59}}
